function [rg d sizes] = gene_score_permutations(D,y,rg,res)
%GENE_SCORE_PERMUTATIONS  Calculate scores, p- and q-values for genes.
%
% Scores each gene by maximum level of deletion among markers within gene 
% for all samples. The overall score fore a gene is the mean for all sample
% scores. P-values are calculated by comparing gene scores against the null 
% distribution of randomly placed genes of the same size on the genomes of 
% all samples.
%
%   [RG DIST SIZES] = GENE_SCORE_PERMUTATIONS(D,Y,RG,RES)
%
% Scores, p- and q-values are generated by adding the fields 'sc', 'p' and
% 'q' to the reference genome RG. DIST returns a cell array of the score
% distributions for each gene size, each bin has width RES. SIZES is a
% distribution of the number of genes for each indexing gene size. Sizes
% are in units of markers.
%
% D is a copy number structure used to position markers and locate genes.
% Y is a marker-by-sample matrix of positive deletion scores. RES is
% the resolution used for the score distribution.

% GISTIC software version 2.0
% Copyright (c) 2011, 2016 Gad Getz, Rameen Beroukhim, Craig Mermel, 
% Jen Dobson, Steve Schumacher, Nico Stransky, Mike Lawrence, Gordon Saksena
% All Rights Reserved.
%
% See the accompanying file LICENSE.txt for licensing details.

pthresh = 0.05;

%% score observed gene deletions

% assign markers to genes
if ~isfield(rg,'snps')
  rg=add_snps_to_rg(rg,D);
end


% Ensure that the maximum number of markers on a gene is smaller than the
% minimum number of markers on a chromosome (gene-gistic requirement). If
% not exit with empty outputs
if max([rg.nsnps]) >= min(accumarray(D.chrn,1));
    warning('gistic:gene_gistic:gene_too_large',...
            'markers on largest gene exceed markers on smallest chromosome: overriding gene-gistic');
    rg = [];
    d = [];
    sizes = [];
    return;
end

% only consider genes with at least 1 snp
probed_genes = find(cell2mat({rg.nsnps}) > 0);
unprobed_genes = find(cell2mat({rg.nsnps}) == 0);

% calculate observed score per gene = mean across samples of max score within gene
verbose('Scoring gene deletions...',20);
for i = 1:length(probed_genes)
  rg(probed_genes(i)).sc = mean(max(y(rg(probed_genes(i)).snps,:),[],1));
  if mod(i,1000) == 0
    verbose('...scored %d of %d genes',30,i,length(probed_genes));
  end
end

%%% score unprobed genes -1
for i = 1:length(unprobed_genes)
  rg(unprobed_genes(i)).sc = -1;
end
max_sc_bin = max(1,ceil(max([rg.sc])/res));

%% determine null distributions for each gene size
%
% Since the overall gene score is simply a mean of sample scores, the null
% distribution for this mean can be calculated by convoluting all of the
% sample score distributions. Rather than recalculate the score distribution
% for each sample/gene size from scratch, this algorithm starts with the 
% distributions for genes with size one marker, and then adjusts these 
% distributions for increasing gene sizes using a segmented representation
% of the score.
%
% The segmented scores are stored as a sequential list of segment
% (length,score) pairs. As the gene size window increases, the adjustment
% to the maximum score distriobution from each segment varies as follows:
%
% - for 'convex' segments that have smaller scores than either adjoining 
%   segment, the contribution to the distribution at its score bin will be 
%   reduced by the amount of the window increase
% - for 'concave' segments that have larger scores than either adjoining 
%   segment, the contribution will be increased.
% - for 'stairstep' segments that are larger than one adjacent segment and
%   smaller than the other, the contribution will remain unchanged.
%
% The chromosomal boundaries have effectively infinite scores in this
% schema - extremal segments act concave if less than the next segment in
% and stairstep if greater. 

% gene sizes determine window sizes to test
sizes = hist(cell2mat({rg.nsnps}),1:max(cell2mat({rg.nsnps})));
nsizes=nnz(sizes);

[s,n] = size(y); % s markers by n samples

% calculate histogram of scores for each sample as baseline single-marker
% gene distribution and store in a cell array
ha = cell(n,1);
for i = 1:n
  ha{i}=histc(y(:,i)/n,0:res:(max(y(:,i))/n+res));
  if mod(i,100)==0
    verbose(['Histograming sample ',num2str(i)],20);
  end
end

%% create a cell array of struct vectors to hold segment (length,value) pairs
chrn_rl = runlength(D.chrn);
score_rl = runlength(y,chrn_rl);
nchr = size(chrn_rl,1);
segindex = cell(n,nchr); % samples x chromosomes
for i = 1:n
    for ch = 1:nchr
       pick = D.chrn(score_rl{i}(:,1)) == ch;
       segindex{i,ch} = struct(...
                      'length',score_rl{i}(pick,2)-score_rl{i}(pick,1)+1,...
                      'score',score_rl{i}(pick,3) );
    end
end


%% gene size loop

% outputs
d = cell(length(sizes),1); % probablility distribution across all samples
t = cell(size(d)); % reverse cumulative distribution function

% working data
jold = 1;
sizes_len = length(sizes);
ngp = s; % number of gene positions for current size

bin_size = n*res;

for j = 1:sizes_len
  verbose(['Window size = ' num2str(j) ' out of ' num2str(sizes_len) ' (non-empty = ' num2str(nsizes) ')' ],20);
  if sizes(j) ~= 0 || j==1
    % at least one gene is this size, or special case size 1 used for pval <-> score mapping 
    if j > 1
      % window size > 1 - correct distribution for extreme value
      jdiff = j - jold;
      for i = 1:n % loop over samples
        for ch = 1:nchr % loop over chromosomes in sample
          seglens = [segindex{i,ch}.length];
          segvals = [segindex{i,ch}.score];
          % if there are any segments
          if ~isempty(seglens) && ~isempty(segvals)
            sizediff = jdiff;
            while sizediff > 0
              % identify convex (1), stairstep (0), and concave (-1) segments
              vexitude = sign(diff(sign(diff([Inf;segvals;Inf]))));
              assert(sum(vexitude) == 1);
              minvex = min(seglens(vexitude>0));
              sizadj = min(sizediff,minvex);
              % adjust segment sizes
              seglens = seglens - sizadj * vexitude;
              % adjust sample histogram
              segbins = floor(segvals/bin_size)+1;
              ha{i} = ha{i} - accumarray(segbins,sizadj*vexitude,size(ha{i}));

              % remove any zero-sized convex segments
              if sizadj == minvex
                killsegs = (seglens == 0);
                seglens(killsegs) = [];
                segvals(killsegs) = [];
                % exit loop if all segments have been eliminated
                if all(killsegs)
                    break;
                end
                % combine any adjacent segments with identical values
                if any(diff(segvals)==0)
                  k = 1;
                  while k < length(segvals)
                    while segvals(k) == segvals(k+1)
                      seglens(k) = seglens(k) + seglens(k+1);
                      seglens(k+1) = [];
                      segvals(k+1) = [];
                      if k >= length(segvals) % last segment merge
                        break;
                      end
                    end
                    k = k+1;
                  end
                end
                % store changed segment values
                [segindex{i,ch}.score] = segvals;
              end

              % adjust gene size difference by amount segments were shortened
              sizediff = sizediff - sizadj;
            end % while sizediff > 0
            % store adjusted segment lengths
            [segindex{i,ch}.length] = seglens;
          end % ~isempty(seglens)
        end % loop over chromosomes in sample
      end % loop over samples
      % adjust number-of-positions normalization
      ngp = ngp - jdiff * nchr;
     
    end % if j > 1
    
    % convolute all the sample distribution to get overall distribution
    fprintf(1,'Conv:.');
    dj = ha{1}/ngp;
    dotskip = ceil((length(ha)-1)/80);
    for i = 2:length(ha);
      dj = conv(dj,ha{i}/ngp);
      if mod(i,dotskip) == 0
        fprintf(1,'.');
      end
      if length(dj) > max_sc_bin
        dj(max_sc_bin) = sum(dj(max_sc_bin:end));
        dj=dj(1:max_sc_bin);
      end
    end
    fprintf(1,'\n');
    % save all-sample score distribution for this size
    d{j} = dj;
    
    % normalize distribution (convolution causes roundoff error)
    sd = sum(d{j});
    if abs(sd-1) > 0.1
      error('not a distribution');
    else
      d{j}=d{j} ./ sd;
    end
    % generate inverse cumulative distribution function
    t{j} = flipud(cumsum(flipud(d{j})));
 
    % track last gene size
    jold = j;

  else
    % sizes(j) == 0
    t{j} = pthresh; 
  end
  
end % for j (loop over gene sizes)

%% look up gene p-values from cumulative distribution of score for gene size
for i = 1:length(probed_genes)
  gene = rg(probed_genes(i));
  tg = t{min(gene.nsnps,j)};
  rg(probed_genes(i)).p = tg(min(1+floor(gene.sc/res),length(tg)));
end

%% calculate q-values from p-values
q = calc_fdr_value(cell2mat({rg.p}));
for i = 1:length(probed_genes)
  rg(probed_genes(i)).q = q(i);
end
      
